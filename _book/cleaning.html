<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta property="og:title" content="Modeling Runners’ Times in the Cherry Blossom Race" />
<meta property="og:type" content="book" />





<meta name="author" content="John Ensley" />

<meta name="date" content="2017-10-23" />

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>

<meta name="description" content="Modeling Runners’ Times in the Cherry Blossom Race">

<title>Modeling Runners’ Times in the Cherry Blossom Race</title>

<link href="libs/tufte-css/tufte.css" rel="stylesheet" />


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>


<link rel="stylesheet" href="toc.css" type="text/css" />

</head>

<body>



<div class="row">
<div class="col-sm-12">
<div id="TOC">
<ul>
<li><a href="index.html#preface">Preface</a></li>
<li><a href="introduction.html#introduction"><span class="toc-section-number">1</span> Introduction</a></li>
<li><a href="scraping.html#scraping"><span class="toc-section-number">2</span> Scraping Race Results from the Web</a></li>
<li><a href="reading.html#reading"><span class="toc-section-number">3</span> Reading Tables of Race Results into R</a></li>
<li><a href="cleaning.html#cleaning"><span class="toc-section-number">4</span> Data Cleaning and Reformatting Variables</a></li>
<li><a href="exploring.html#exploring"><span class="toc-section-number">5</span> Exploring the Run Time for All Male Runners</a></li>
<li><a href="individuals.html#individuals"><span class="toc-section-number">6</span> Constructing a Record for an Individual Runner across Years</a></li>
<li><a href="modeling-the-change-in-running-time-for-individuals.html#modeling-the-change-in-running-time-for-individuals"><span class="toc-section-number">7</span> Modeling the Change in Running Time for Individuals</a></li>
<li><a href="exercises.html#exercises"><span class="toc-section-number">8</span> Exercises</a></li>
</ul>
</div>
</div>
</div>
<div class="row">
<div class="col-sm-12">
<div id="cleaning" class="section level1">
<h1><span class="header-section-number">4</span> Data Cleaning and Reformatting Variables</h1>
<p>In this section, we consider how to convert the list of character matrices, <code>men_res_mat</code>, into an appropriate format for analysis. Currently, the data values are all character, which is not conducive to, e.g., finding the median age of the runners. However, we can easily reformat age into numeric values with the <code>as.numeric()</code> function. Do we want to turn the entire matrix into a numeric matrix? Not really. It doesn’t make sense to try to convert the runner’s name into a numeric value. For this reason, we want to create a data frame because it allows our variables to be different types. We have 6 variables: the runner’s name, home town, age, and 3 versions of time. As just mentioned, we want to convert age to a numeric and leave name as character. What about the other variables? We probably want to also keep hometown as character.</p>
<p>Time is stored as a string in the format: <code>hh:mm:ss</code>. We want time in a numeric format so it can be more easily summarized and modeled. For this, we will use the <code>lubridate</code> package, which is excellent for converting character strings to dates and times. We also need to reconcile the 3 different recorded times (gun, net, and plain time). Net time is considered more accurate than gun time so we can simply use net time when available and otherwise use gun time or time, whichever is reported. Of course, we can keep all 3 versions of time around and let the analyst explore relationships between them and decide which to use, but we keep things simple for now and just report one time for each runner.</p>
<p>Before we begin converting our character strings into numeric values, we also consider whether there are any new variables we might want to create. If we are to combine all the data from the 14 years of records into one data frame, then we should keep track of the year. Likewise, if we are to combine the men’s and women’s results then we also want a variable that indicates the sex of the runner. These are very simple to make when combining data frames with <code>dplyr::bind_rows()</code>.</p>
<p>We begin with the task of creating the numeric variable <code>age</code> with <code>as.numeric()</code>, e.g., for the 2012 males,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">age &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(men_res_mat<span class="op">$</span><span class="st">`</span><span class="dt">2012</span><span class="st">`</span>[ ,<span class="st">&#39;ag&#39;</span>])</code></pre></div>
<p>Note that we subsetted the list to work with the 2012 matrix and then subsetted this matrix to work with the column named <code>ag</code>. We check a few <code>age</code> values with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(age)</code></pre></div>
<pre><code>## [1] 41 39 56 35 NA 48</code></pre>
<p>These values look reasonable, but let’s check more thoroughly that our data extraction works as expected by summarizing each year’s ages with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">age &lt;-<span class="st"> </span><span class="kw">map</span>(men_res_mat, <span class="op">~</span><span class="st"> </span><span class="kw">as.numeric</span>(.x[ ,<span class="st">&#39;ag&#39;</span>]))</code></pre></div>
<pre><code>## Warning in .f(.x[[i]], ...): NAs introduced by coercion

## Warning in .f(.x[[i]], ...): NAs introduced by coercion

## Warning in .f(.x[[i]], ...): NAs introduced by coercion</code></pre>
<p>We received a warning message that our conversion of the character values for age into numeric resulted in <code>NA</code> values, meaning that some of the values do not correspond to numbers. We want to look into the specific cause of these messages, but first we examine <code>age</code>.</p>
<p>We create side-by-side boxplots of the yearly distribution of the age of the runners to give a quick check on the reasonableness of the values.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">age <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">enframe</span>(<span class="dt">name =</span> <span class="st">&#39;year&#39;</span>, <span class="dt">value =</span> <span class="st">&#39;age&#39;</span>) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">unnest</span>() <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">ggplot</span>(<span class="kw">aes</span>(year, age)) <span class="op">+</span>
<span class="st">  </span><span class="kw">geom_boxplot</span>()</code></pre></div>
<pre><code>## Warning: Removed 66 rows containing non-finite values (stat_boxplot).</code></pre>
<div class="figure"><span id="fig:ageboxplot"></span>
<p class="caption marginnote shownote">
Figure 4.1: Box Plot of Age by Year. These side-by-side boxplots of age for each race year show a few problems with the data for 2003 and 2006. The runners in these years are unusually young.
</p>
<img src="_main_files/figure-html/ageboxplot-1.png" alt="Box Plot of Age by Year. These side-by-side boxplots of age for each race year show a few problems with the data for 2003 and 2006. The runners in these years are unusually young." width="672"  />
</div>
<p>Figure <a href="cleaning.html#fig:ageboxplot">4.1</a> reveals problems with 2 years. All of the runners in 2003 were under 10 and more than 1 in 4 runners in 2006 were under 10! Clearly something has gone wrong.</p>
<p>Let’s examine the original text for 2003 and 2006.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(men_files<span class="op">$</span><span class="st">`</span><span class="dt">2003</span><span class="st">`</span>)</code></pre></div>
<pre><code>## [1] &quot;&quot;                                                                                             
## [2] &quot;Place Div /Tot  Num    Name                          Ag Hometown            Gun Tim  Net Tim &quot;
## [3] &quot;===== ========= ===== ============================= == =================== =======  ======= &quot; 
## [4] &quot;    1    1/1999     6  John Korir                    27  KEN                  46:56#   46:55 &quot;
## [5] &quot;    2    2/1999     1  Reuben Cheruiyot              28  KEN                  47:03#   47:02 &quot;
## [6] &quot;    3    3/1999     8  Gilbert Okari                 24  KEN                  47:07#   47:07 &quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_files<span class="op">$</span><span class="st">`</span><span class="dt">2006</span><span class="st">`</span>[<span class="dv">2200</span><span class="op">:</span><span class="dv">2205</span>]</code></pre></div>
<pre><code>## [1] &quot; 2192 1263/2892   1475 Matt Curtis            39 Vienna          1:27:08 1:27:40   8:46   &quot;
## [2] &quot; 2193  94/279    1437 Joe McCloskey          59 Columbia        1:27:01 1:27:40   8:46   &quot; 
## [3] &quot; 2194 257/590    7062 Donald Hofmann         48 Princeton Junct 1:25:45 1:27:41   8:47   &quot; 
## [4] &quot; 2195 1264/2892   7049 Claudio Petruzziello   23 Princeton Jct   1:25:45 1:27:41   8:47   &quot;
## [5] &quot; 2196 339/746    3319 Robert Morrison        40 South Boston    1:23:54 1:27:41   8:47   &quot; 
## [6] &quot; 2197 1265/2892   9345 Larry Cooper           32 Arlington       1:26:42 1:27:41   8:47   &quot;</code></pre>
<p>We see that in 2003, the age values are shifted to the right one space in comparison to the location of the ‘=’ characters. This means that we are picking up only the digit in the tens place. In 2006, some but not all of the rows have values that are off by one character.</p>
<p>We can easily solve both of these problems by including the value in the “blank” space between columns. We can do this by changing the index for the end of each variable when we perform the extraction. That is, we modify the line in <code>select_cols()</code> that locates the end of a column to include the blank position, i.e.,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">select_cols &lt;-<span class="st"> </span><span class="cf">function</span>(col_names, header_row, search_locs) {
  select_col &lt;-<span class="st"> </span><span class="cf">function</span>(name, header_row, search_locs) {
    start_pos &lt;-<span class="st"> </span><span class="kw">str_locate</span>(header_row, name)[<span class="dv">1</span>,<span class="dv">1</span>]
    <span class="cf">if</span> (<span class="kw">is.na</span>(start_pos)) <span class="kw">return</span>(<span class="kw">c</span>(<span class="ot">NA</span>, <span class="ot">NA</span>))
    index &lt;-<span class="st"> </span><span class="kw">sum</span>(start_pos <span class="op">&gt;=</span><span class="st"> </span>search_locs)
    <span class="kw">c</span>(search_locs[index] <span class="op">+</span><span class="st"> </span><span class="dv">1</span>, search_locs[index <span class="op">+</span><span class="st"> </span><span class="dv">1</span>])
  }
  
  <span class="kw">map</span>(col_names, select_col, 
      <span class="dt">header_row =</span> header_row, 
      <span class="dt">search_locs =</span> search_locs) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">    </span><span class="kw">do.call</span>(<span class="st">&#39;rbind&#39;</span>, .)
}</code></pre></div>
<p>When we use this revised calculation in <code>select_cols()</code>, we pick up the blank character after each field. This should not matter when we convert our text data to numeric and if we don’t want trailing blanks in our character-valued variables, we can easily remove them with regular expressions.</p>
<p>In the process of confirming our conversion of age from character to numeric, we uncovered problems with our extraction process. We need to modify our helper function <code>select_cols()</code> from Chapter <a href="reading.html#reading">3</a> to address the problem. This process is iterative as we continue to check that our data make sense. When we uncover nonsensical results, we investigate them further, which possibly leads to retracing our steps to clean up messy data.</p>
<p>After we modify this one line of code in <code>select_cols()</code> and reapply this updated version of the function to the tables of race results, we check again the summary statistics with boxplots. We find that the problem with too many young runners has cleared up (see Figure <a href="cleaning.html#fig:ageboxplots-fixed">4.2</a>).</p>
<pre><code>## Warning: Removed 64 rows containing non-finite values (stat_boxplot).</code></pre>
<div class="figure"><span id="fig:ageboxplots-fixed"></span>
<p class="caption marginnote shownote">
Figure 4.2: Box Plot of Age by Year. These side-by-side boxplots of age for each race year show a reasonable age distribution. For example, the lower quartile for all years range between 29 and 32. The problems identified earlier for 2003 and 2006 have been addressed.
</p>
<img src="_main_files/figure-html/ageboxplots-fixed-1.png" alt="Box Plot of Age by Year. These side-by-side boxplots of age for each race year show a reasonable age distribution. For example, the lower quartile for all years range between 29 and 32. The problems identified earlier for 2003 and 2006 have been addressed." width="672"  />
</div>
<p>We now turn to the warning messages that occurred when we converted the character strings for age to numeric values. We were given several messages ‘NAs introduced by coercion’. We count the number of <code>NA</code> values in each year with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_int</span>(age, <span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">is.na</span>(.)))</code></pre></div>
<pre><code>## 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 
##    1    1   28    3    2    0   13    2    5    0    2    6    0    1</code></pre>
<p>In 2001, we have 62 <code>NA</code>s for age. We need to investigate. To make our work simpler, let’s assign the 2001 ages to a vector called <code>age2001</code>. We do this with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">age2001 &lt;-<span class="st"> </span>age<span class="op">$</span><span class="st">`</span><span class="dt">2001</span><span class="st">`</span></code></pre></div>
<p>Let’s examine the original rows in the file that correspond to an <code>NA</code> in <code>age2001</code>. Recall that we dropped the header of the file before extracting the variables so we need to add an offset to the location of the <code>NA</code>s in <code>age2001</code> in order to pick out the correct rows in the original table. We find the offset with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">offset &lt;-<span class="st"> </span><span class="kw">str_which</span>(men_files<span class="op">$</span><span class="st">`</span><span class="dt">2001</span><span class="st">`</span>, <span class="st">&#39;^===&#39;</span>)
offset</code></pre></div>
<pre><code>## [1] 5</code></pre>
<p>We then find the lines in the original file that have the bad age values with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bad_age_idx &lt;-<span class="st"> </span><span class="kw">which</span>(<span class="kw">is.na</span>(age2001)) <span class="op">+</span><span class="st"> </span>offset
<span class="kw">tail</span>(men_files<span class="op">$</span><span class="st">`</span><span class="dt">2001</span><span class="st">`</span>[bad_age_idx])</code></pre></div>
<pre><code>## [1] &quot; 2832  3969 Dave DOHERTY          27 Arlington VA       1:29:55 1:38:56&quot;
## [2] &quot; 2922  1301 Michael DAVIS         38 Rockville MD       1:35:01 1:40:00&quot;
## [3] &quot; 2923  3156 Ed RIDGWAY            52 Reston VA          1:36:08 1:40:05&quot;
## [4] &quot; 2924 23819 Craig BLAKELEY        48 Vienna VA          1:38:03 1:40:06&quot;
## [5] &quot; 2925   917 Stephen GREENE        35 Baltimore MD       1:29:12 1:40:07&quot;
## [6] &quot; 3529  5134 Gary KODECK           49 Reisterstown MD    2:03:37 2:07:23&quot;</code></pre>
<p>To save space, only the last few lines are shown here. With one exception, all of the rows are blank/empty. The one exception is the row that corresponds to the footnote that defines the meaning of the ‘#’ annotation. Where in the table are these rows located?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">bad_age_idx</code></pre></div>
<pre><code>##  [1] 1756 1757 1758 1759 1810 1811 1812 1813 1864 1865 1866 1867 1918 1919
## [15] 1920 2521 2522 2523 2524 2875 2876 2877 2878 2979 2980 2981 2982 3594</code></pre>
<p>These blank lines are scattered throughout the file. We can modify the extraction by checking for blank rows and removing them. The regular expression,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">blanks &lt;-<span class="st"> </span><span class="kw">str_which</span>(men_files[[<span class="st">&#39;2001&#39;</span>]], <span class="st">&#39;^[[:blank:]]*$&#39;</span>)</code></pre></div>
<p>locates all rows that are entirely blank. The second argument to <code>str_which</code> uses several meta characters to specify the pattern to search for. The <code>^</code> is an anchor for denoting the start of the string, the <code>$</code> anchors to the end of the string, the <code>[[:blank:]]</code> denotes the equivalence class of space and tab characters, and the <code>*</code> indicates that the blank character can appear 0 or more times. All together the pattern <code>^[[:blank:]]*$</code> matches a string that contains any number of blanks from start to end, i.e., only blank lines.</p>
<p>A simpler expression locates the footnote rows, i.e., rows that begin with # or *. Here is the modified <code>extract_variables()</code> function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">extract_variables &lt;-<span class="st"> </span><span class="cf">function</span>(file, <span class="dt">var_names =</span> <span class="kw">c</span>(<span class="st">&quot;name&quot;</span>, <span class="st">&quot;home&quot;</span>, <span class="st">&quot;ag&quot;</span>, <span class="st">&quot;gun&quot;</span>, <span class="st">&quot;net&quot;</span>, <span class="st">&quot;time&quot;</span>)) {
  <span class="co"># find the index of the row with =s</span>
  eq_idx &lt;-<span class="st"> </span><span class="kw">str_which</span>(file, <span class="st">&#39;^===&#39;</span>)
  <span class="co"># extract the two key rows and the data</span>
  spacer_row &lt;-<span class="st"> </span>file[eq_idx]
  header_row &lt;-<span class="st"> </span>file[eq_idx <span class="op">-</span><span class="st"> </span><span class="dv">1</span>] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">str_to_lower</span>()
  <span class="co"># find blank lines</span>
  blanks &lt;-<span class="st"> </span><span class="kw">str_which</span>(file, <span class="st">&#39;^[[:blank:]]*$&#39;</span>)
  <span class="co"># find comments</span>
  comments &lt;-<span class="st"> </span><span class="kw">str_which</span>(file, <span class="st">&#39;^[[:blank:]]*[#</span><span class="ch">\\</span><span class="st">*]&#39;</span>)
  <span class="co"># remove header, blank lines, and comments</span>
  body &lt;-<span class="st"> </span>file[<span class="op">-</span><span class="kw">c</span>(<span class="dv">1</span><span class="op">:</span>eq_idx, blanks, comments)]
  
  <span class="co"># get starting and ending positions of variables</span>
  search_locs &lt;-<span class="st"> </span><span class="kw">find_col_locs</span>(spacer_row)
  loc_cols &lt;-<span class="st"> </span><span class="kw">select_cols</span>(var_names, header_row, search_locs)
  values &lt;-<span class="st"> </span><span class="kw">map</span>(body, str_sub, loc_cols) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">do.call</span>(<span class="st">&#39;rbind&#39;</span>, .)
  <span class="kw">colnames</span>(values) &lt;-<span class="st"> </span>var_names
  <span class="kw">invisible</span>(values)
}</code></pre></div>
<p>After adding this code to carry out the additional cleaning of the tables, the 61 <code>NA</code>s in 2001 are gone as well as many but not all of the other <code>NA</code>s in other the years.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_int</span>(age, <span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">is.na</span>(.)))</code></pre></div>
<pre><code>## 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 
##    1    1   28    3    2    0   13    2    5    0    2    6    0    1</code></pre>
<p>Continued inspection of Figure <a href="cleaning.html#fig:ageboxplots-fixed">4.2</a> uncovers another problem – the minimum values for age in 2001, 2002, and 2003 remain small, i.e., close to 0. That’s clearly not possible! Let’s find which runners have an age under 5 and look at their records in the original table. For 2001, we have</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">which</span>(age2001 <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>)</code></pre></div>
<pre><code>## [1] 1377 3030 3079</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_files[[<span class="st">&#39;2001&#39;</span>]][<span class="kw">which</span>(age2001 <span class="op">&lt;</span><span class="st"> </span><span class="dv">5</span>) <span class="op">+</span><span class="st"> </span>offset]</code></pre></div>
<pre><code>## [1] &quot; 1377  5629 Steve PINKOS           0 Washington DC      1:20:07 1:22:34&quot;
## [2] &quot; 2970  5332 Kurt MENKE            38 Springfield VA     1:38:07 1:40:50&quot;
## [3] &quot; 3019  5199 Thomas HAMMER         53 Falls Church VA    1:39:05 1:41:41&quot;</code></pre>
<p>Apparently there are runners with an age entered as 0! Since these are the actual values in the table, we leave the decision as to what to do with these runners for later when we analyze the data. At this point, it appears we have successfully taken care of the creation of the age variable. However, we typically clean the variables simultaneously as an error in one variable often leads to errors in others based on position. As we clean the other variables, we may need to re-examine age to ensure that the values for age remain valid.</p>
<p>Next, we turn to the creation of the time variable. As mentioned at the beginning of this section, the time appears as <code>hh:mm:ss</code> and we wish to convert it to minutes. However, to carry out this computation, we must split the time field up into its constituent pieces. Also, some runners completed the race in under one hour so their times appear in a slightly different format, i.e., <code>mm:ss</code>, and we need to be able to handle both formats in our processing. For simplicity, we again start with converting the time variable for one year, say 2012. We create a vector to develop our code as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">char_time &lt;-<span class="st"> </span>men_res_mat[[<span class="st">&#39;2012&#39;</span>]][ ,<span class="st">&#39;time&#39;</span>]
<span class="kw">head</span>(char_time)</code></pre></div>
<pre><code>## [1] &quot;  45:15 &quot; &quot;  46:28 &quot; &quot;  47:33 &quot; &quot;  47:34 &quot; &quot;  47:40 &quot; &quot;  47:50 &quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(char_time)</code></pre></div>
<pre><code>## [1] &quot;2:26:47 &quot; &quot;2:27:11 &quot; &quot;2:27:20 &quot; &quot;2:27:30 &quot; &quot;2:28:58 &quot; &quot;2:30:59 &quot;</code></pre>
<p>We split each character string up into its parts using <code>str_split()</code> with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">time_pieces &lt;-<span class="st"> </span><span class="kw">str_split</span>(char_time, <span class="st">&#39;:&#39;</span>)</code></pre></div>
<p>The <code>:</code> characters are discarded in the process, and the return value from <code>str_split()</code> is a list of character vectors. We have one vector for each input string, where the elements of the vector contain the pieces of the string separated by each <code>:</code> character. We confirm that the splitting worked properly by examining the first and last times, i.e.,</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">head</span>(time_pieces, <span class="dv">1</span>)</code></pre></div>
<pre><code>## [[1]]
## [1] &quot;  45&quot; &quot;15 &quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">tail</span>(time_pieces, <span class="dv">1</span>)</code></pre></div>
<pre><code>## [[1]]
## [1] &quot;2&quot;   &quot;30&quot;  &quot;59 &quot;</code></pre>
<p>We convert these elements to numeric values and combine them into one value that reports time in minutes with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">run_time &lt;-<span class="st"> </span><span class="kw">map_dbl</span>(time_pieces, <span class="cf">function</span>(x) {
  x &lt;-<span class="st"> </span><span class="kw">as.numeric</span>(x)
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">2</span>) x[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>x[<span class="dv">2</span>] <span class="op">/</span><span class="st"> </span><span class="dv">60</span>
  <span class="cf">else</span> <span class="dv">60</span> <span class="op">*</span><span class="st"> </span>x[<span class="dv">1</span>] <span class="op">+</span><span class="st"> </span>x[<span class="dv">2</span>] <span class="op">+</span><span class="st"> </span>x[<span class="dv">3</span>] <span class="op">/</span><span class="st"> </span><span class="dv">60</span>
})</code></pre></div>
<p>We check our conversion with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(run_time)</code></pre></div>
<pre><code>##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   45.25   77.57   87.47   88.43   97.78  150.98</code></pre>
<p>It appears that our time conversion works. We saw earlier that the fastest runner completed the 2012 race in 45 minutes and 15 seconds, which is 45.25 minutes, and the slowest completed it in 2 hours 30 minutes and 59 seconds, which is nearly 151 minutes. For the sake of reproducibility, we encapsulate this conversion into a function called <code>convert_time()</code>.</p>
<p>Let’s wrap these conversions into a function to apply to the character matrices in menResMat and return a data frame with variables for analysis. We call this function <code>create_df()</code>. In addition to the conversion of character strings to numeric, we also create two new variables, year and sex. To do this, we must have input arguments to tell us which year we are cleaning and whether the results are for men or women. Lastly, we also choose which time variable to include in the data frame from among the 3 available, with a preference for net time. The function appears as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">create_df &lt;-<span class="st"> </span><span class="cf">function</span>(res, year, sex) {
  <span class="co"># determine which time to use</span>
  use_time &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="op">!</span><span class="kw">is.na</span>(res[<span class="dv">1</span>,<span class="st">&#39;net&#39;</span>])) {
                res[ ,<span class="st">&#39;net&#39;</span>]
              } <span class="cf">else</span> <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.na</span>(res[<span class="dv">1</span>,<span class="st">&#39;gun&#39;</span>])) {
                res[ ,<span class="st">&#39;gun&#39;</span>]
              } <span class="cf">else</span> {
                res[ ,<span class="st">&#39;time&#39;</span>]
              }
  run_time &lt;-<span class="st"> </span><span class="kw">convert_time</span>(use_time)
  
  results &lt;-<span class="st"> </span><span class="kw">data_frame</span>(<span class="dt">year =</span> year,
                        <span class="dt">sex =</span> sex,
                        <span class="dt">name =</span> res[ ,<span class="st">&#39;name&#39;</span>],
                        <span class="dt">home =</span> res[ ,<span class="st">&#39;home&#39;</span>],
                        <span class="dt">age =</span> <span class="kw">as.numeric</span>(res[ ,<span class="st">&#39;ag&#39;</span>]),
                        <span class="dt">time =</span> run_time)
  
  <span class="kw">invisible</span>(results)
}</code></pre></div>
<p>We apply our new function, <code>create_df()</code>, to all of the male results as follows:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_df &lt;-<span class="st"> </span><span class="kw">map2</span>(men_res_mat, <span class="dv">1999</span><span class="op">:</span><span class="dv">2012</span>, create_df, <span class="dt">sex =</span> <span class="st">&#39;m&#39;</span>)
<span class="kw">warnings</span>()[<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">49</span>, <span class="dv">50</span>)]</code></pre></div>
<pre><code>## NULL</code></pre>
<p>It is likely that the conversion problems are coming from the conversion of time from a character string into minutes because we have already handled the conversion of age. We can check the number of <code>NA</code> values for <code>time</code> with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(men_df, <span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">is.na</span>(.x<span class="op">$</span>time)))</code></pre></div>
<pre><code>## 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 
##    0    0    1    0    0    0    0 5232   83    0  164   68    0    0</code></pre>
<p>There are a large number of <code>NA</code>s in 2007, 2009, and 2010, and it appears that all of the run time values for 2006 are <code>NA</code>.</p>
<p>Let’s begin by examining a few of the records in 2007, 2009, and 2010 that have an <code>NA</code> in run time. We find that these are caused by runners who completed half the race but have no final times and by runners who have a footnote after their time, e.g.,</p>
<pre><code>## [1] &quot;    1     1/54        13 Tadesse Tola           19 Ethiopia             46:01#  4:37     28:47 &quot;
## [2] &quot; 5273   309/309    16370 Stephen Peterson       57 Washington DC             #         1:36:29 &quot;</code></pre>
<p>We can easily modify <code>create_df()</code> to eliminate the footnote symbols (# and *) from the times and drop records of runners who do not complete the race. These revisions are</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">create_df &lt;-<span class="st"> </span><span class="cf">function</span>(res, year, sex) {
  <span class="co"># determine which time to use</span>
  use_time &lt;-<span class="st"> </span><span class="cf">if</span> (<span class="op">!</span><span class="kw">is.na</span>(res[<span class="dv">1</span>,<span class="st">&#39;net&#39;</span>])) {
                res[ ,<span class="st">&#39;net&#39;</span>]
              } <span class="cf">else</span> <span class="cf">if</span> (<span class="op">!</span><span class="kw">is.na</span>(res[<span class="dv">1</span>,<span class="st">&#39;gun&#39;</span>])) {
                res[ ,<span class="st">&#39;gun&#39;</span>]
              } <span class="cf">else</span> {
                res[ ,<span class="st">&#39;time&#39;</span>]
              }
  <span class="co"># remove #, *, and blanks from time</span>
  use_time &lt;-<span class="st"> </span><span class="kw">str_replace_all</span>(use_time, <span class="st">&#39;[#</span><span class="ch">\\</span><span class="st">*[:blank:]]&#39;</span>, <span class="st">&#39;&#39;</span>)
  <span class="co"># drop rows with no time</span>
  res &lt;-<span class="st"> </span>res[use_time <span class="op">!=</span><span class="st"> &#39;&#39;</span>, ]
  run_time &lt;-<span class="st"> </span><span class="kw">convert_time</span>(use_time[use_time <span class="op">!=</span><span class="st"> &#39;&#39;</span>])
  
  results &lt;-<span class="st"> </span><span class="kw">data_frame</span>(<span class="dt">year =</span> year,
                        <span class="dt">sex =</span> sex,
                        <span class="dt">name =</span> res[ ,<span class="st">&#39;name&#39;</span>],
                        <span class="dt">home =</span> res[ ,<span class="st">&#39;home&#39;</span>],
                        <span class="dt">age =</span> <span class="kw">as.numeric</span>(res[ ,<span class="st">&#39;ag&#39;</span>]),
                        <span class="dt">time =</span> run_time)
  
  <span class="kw">invisible</span>(results)
}</code></pre></div>
<p>After we apply this revised function to <code>men_res_mat</code> to create our data frame, most missing values are gone except for 2006.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">map_dbl</span>(men_df, <span class="op">~</span><span class="st"> </span><span class="kw">sum</span>(<span class="kw">is.na</span>(.x<span class="op">$</span>time)))</code></pre></div>
<pre><code>## 1999 2000 2001 2002 2003 2004 2005 2006 2007 2008 2009 2010 2011 2012 
##    0    0    1    0    0    0    0 5232    0    0    0    0    0    0</code></pre>
<p>Let’s look at the missing value for 2001.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_df[[<span class="st">&#39;2001&#39;</span>]] <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">filter</span>(<span class="kw">is.na</span>(time))</code></pre></div>
<pre><code>## # A tibble: 1 x 6
##    year   sex                   name                home   age  time
##   &lt;int&gt; &lt;chr&gt;                  &lt;chr&gt;               &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1  2001     m Peter HUI              Silver Spring MD       70    NA</code></pre>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="kw">grep</span>(<span class="st">&#39;Peter HUI&#39;</span>, men_files[[<span class="st">&#39;2001&#39;</span>]])
men_files[[<span class="st">&#39;2001&#39;</span>]][(i<span class="op">-</span><span class="dv">1</span>)<span class="op">:</span>(i<span class="op">+</span><span class="dv">1</span>)]</code></pre></div>
<pre><code>## [1] &quot; 2249  3668 Jeff DRAMSTAD         35 Arlington VA       1:26:08 1:31:46&quot;
## [2] &quot; 2250  4666 Peter HUI             70 Silver Spring MD   1:30:&quot;          
## [3] &quot; 2251  3134 King ADKINS           51 La Plata MD        1:27:44 1:31:48&quot;</code></pre>
<p>Somehow this runner’s time got entered incorrectly. Because runners are listed in order of their time, we can infer that he probably had a time of 1:31:47. We’ll fill in that value manually.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_df[[<span class="st">&#39;2001&#39;</span>]]<span class="op">$</span>time[<span class="dv">2250</span>] &lt;-<span class="st"> </span><span class="dv">91</span> <span class="op">+</span><span class="st"> </span><span class="dv">47</span><span class="op">/</span><span class="dv">60</span></code></pre></div>
<p>As for 2006, the problem can be seen when we look at the header lines of that file.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">men_files[[<span class="st">&#39;2006&#39;</span>]][<span class="dv">7</span><span class="op">:</span><span class="dv">11</span>]</code></pre></div>
<pre><code>## [1] &quot;Place Div/Tot  Num    Name                   Ag Hometown        Net Tim Gun Tim  Pace  S &quot;
## [2] &quot;===== ======== ====== ====================== == ======================= =======  ===== = &quot;
## [3] &quot;    1   1/2892      1 Gilbert Okari          27 Kenya             47:24   47:25#  4:45   &quot;
## [4] &quot;    2   2/2892     11 Samuel Ndereba         29 Kenya             47:34   47:35#  4:46   &quot;
## [5] &quot;    3   3/2892      3 Rueben Kibet Chebii    23 Kenya             47:38   47:39#  4:46   &quot;</code></pre>
<p>The separator line of ’=’s does not have a space between the “Hometown” and “Net Tim” columns. The easiest thing to do in this scenario is to just alter the separator line directly and rerun <code>extract_variables()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">spacer_row_<span class="dv">2006</span> &lt;-<span class="st"> </span>men_files[[<span class="st">&#39;2006&#39;</span>]][<span class="dv">8</span>]
<span class="kw">str_sub</span>(spacer_row_<span class="dv">2006</span>, <span class="dv">64</span>, <span class="dv">64</span>) &lt;-<span class="st"> &#39; &#39;</span>
men_files[[<span class="st">&#39;2006&#39;</span>]][<span class="dv">8</span>] &lt;-<span class="st"> </span>spacer_row_<span class="dv">2006</span>
men_files[[<span class="st">&#39;2006&#39;</span>]][<span class="dv">7</span><span class="op">:</span><span class="dv">11</span>]</code></pre></div>
<pre><code>## [1] &quot;Place Div/Tot  Num    Name                   Ag Hometown        Net Tim Gun Tim  Pace  S &quot;
## [2] &quot;===== ======== ====== ====================== == =============== ======= =======  ===== = &quot;
## [3] &quot;    1   1/2892      1 Gilbert Okari          27 Kenya             47:24   47:25#  4:45   &quot;
## [4] &quot;    2   2/2892     11 Samuel Ndereba         29 Kenya             47:34   47:35#  4:46   &quot;
## [5] &quot;    3   3/2892      3 Rueben Kibet Chebii    23 Kenya             47:38   47:39#  4:46   &quot;</code></pre>
<p>At last, we combine the race results for all years and men into one data frame using <code>purrr::map2_dfr()</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">write_csv</span>(men_df, <span class="st">&#39;men/men_df.csv&#39;</span>)</code></pre></div>
<p>We check the dimension of our amalgamated data frame with</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">dim</span>(men_df)</code></pre></div>
<pre><code>## [1] 70070     6</code></pre>
<p>We also examine a summary of the variables in cbMen to check whether any problems arose, e.g., with coercion, in the binding together of the data frames.</p>
<p>Over these 14 years, 70,070 male runners completed the Cherry Blossom race. In addition, more than 70,000 female runners completed the race. We leave it as an exercise to handle the women’s race results. In the next section we take a closer look at the race results.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">women_res_mat &lt;-<span class="st"> </span><span class="kw">map</span>(women_files, extract_variables)
women_files[[<span class="st">&#39;2006&#39;</span>]][<span class="dv">8</span>] &lt;-<span class="st"> </span>spacer_row_<span class="dv">2006</span>
women_df &lt;-<span class="st"> </span><span class="kw">map2_dfr</span>(women_res_mat, <span class="dv">1999</span><span class="op">:</span><span class="dv">2012</span>, create_df, <span class="dt">sex =</span> <span class="st">&#39;f&#39;</span>)
women_df[<span class="kw">grep</span>(<span class="st">&#39;^Marie-Laure Poir&#39;</span>, women_df<span class="op">$</span>name),<span class="st">&#39;name&#39;</span>] &lt;-<span class="st"> &#39;Marie-Laure Poire&#39;</span>
women_df &lt;-<span class="st"> </span>women_df <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw">mutate_if</span>(is_character, <span class="kw">funs</span>(<span class="kw">str_trim</span>(., <span class="dt">side =</span> <span class="st">&#39;both&#39;</span>))) <span class="op">%&gt;%</span><span class="st"> </span>
<span class="st">  </span><span class="kw">mutate</span>(<span class="dt">name =</span> <span class="kw">str_to_title</span>(name))
<span class="kw">write_csv</span>(women_df, <span class="st">&#39;women/women_df.csv&#39;</span>)</code></pre></div>

</div>
<p style="text-align: center;">
<a href="reading.html"><button class="btn btn-default">Previous</button></a>
<a href="exploring.html"><button class="btn btn-default">Next</button></a>
</p>
</div>
</div>



</body>
</html>
